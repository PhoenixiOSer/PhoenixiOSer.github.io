[{
    "title": "读《程序员的自我修养-链接、装载与库》—— 目标文件结构",
    "date": "",
    "description": "",
    "body": "目标文件里有什么 目标文件就是源代码编译后但未进行链接的那些中间文件（Windows的.obj和Linux下的.o）。只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整，其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种，他不太常见的可执行文件格式还有Intel/Microsoft的OMF（Object Module Format）、Unix a.out格式和MS-DOS .COM格式等。\n其实不光是可执行文件（Windows的.exe和Linux下的ELF可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library）（Windows的.dll和Linux的.so）及静态链接库（Static Linking Library）（Windows的.lib和Linux的.a）文件都按照可执行文件格式存储。\n目标文件是什么样的 目标文件中的内容至除了编译后的机器指令代码、数据以外，还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。\n程序源代码编译后的机器指令经常被放在代码段（Code Section）里，代码段常见的名字有“.code”或“.text”；全局变量和局部静态变量数据经常放在数据段（Data Section），数据段的一般名字都叫“.data”。让我们来看一个简单的程序被编译成目标文件后的结构，一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment）。\n可执行文件的的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，文件头还包括一个段表（Section Table），段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，比如代码段保存的就是程序的指令，数据段保存的就是程序的静态变量等。\n对照上图来看，一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在. data段；未初始化的全局变量和局部静态变量一般放在一个叫.“bss”的段里。\n挖掘SimpleSection.o /* * SimpleSection.c * Linux: * gcc -c SimpleSection.c * * Windows: * cl SimpleSection.c /c /Za */ int printf( const char* format, ... ); int global_init_var = 84; int global_uninit_var; void func1( int i ) { printf( \u0026quot;%d\\n\u0026quot;, i ); } int main(void) { static int static_var = 85; static int static_var2; int a = 1; int b; func1( static_var + static_var2 + a + b ); return a; } 我们就以 SimpleSection.c 编译出来的目标文件作为分析对象，来深入了解目标文件的具体细节，下所分析的都是32位Intel x86平台下的ELF文件格式。\n在命令行输入gcc -c SimpleSection.c,-c 表示只编译不链接,我们会得到 SimpleSection.o 目标文件。我们直接使用binutils的工具objdump来查看目标文件的结构和内容。\n$ objdump -h SimpleSection.o SimpleSection.o: file format elf32-i386 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000005b 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 00000000 00000000 00000090 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 00000000 00000000 00000098 2**2 ALLOC 3 .rodata 00000004 00000000 00000000 00000098 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 0000002a 00000000 00000000 0000009c 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 00000000 00000000 000000c6 2**0 CONTENTS, READONLY 我们先来把ELF段的结构分析清楚。从上面的结果来看，SimpleSection.o的段的数量比我们想象中的要多，除了最基本的代码段、数据段和BSS段以外，还有3个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GNU-stack）。其中最容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段的第2行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在文件中存在。我们可以看到BSS段没有“CONTENTS”，表示它实际上在ELF文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但它的长度为0，这是个很古怪的段，我们暂且忽略它，认为它在ELF文件中也不存在。那么ELF文件中实际存在的也就是“.text”、“.data”、“.rodata”和“.comment”这4个段了，它们的长度和在文件中的偏移位置我们已经用粗体表示出来了。它们在ELF中的结构如图：\n代码段 一般C语言的编译后执行语句都编译成机器代码，保存在.text段。objdump的 “-s ”参数可以将所有段的内容以十六进制的方式打印出来 ，“-d ”参数可以将所有包含指令的段反汇编。我们将objdump输出中关于代码段的内容提取出来，分析一下关于代码段的内容（省略号表示略去无关内容）：\n“$ objdump -s -d SimpleSection.o …… Contents of section .text: 0000 5589e583 ec088b45 08894424 04c70424 U......E..D$...$ 0010 00000000 e8fcffff ffc9c38d 4c240483 ............L$.. 0020 e4f0ff71 fc5589e5 5183ec14 c745f401 ...q.U..Q....E.. 0030 0000008b 15040000 00a10000 00008d04 ................ 0040 020345f4 0345f889 0424e8fc ffffff8b ..E..E...$...... 0050 45f483c4 14595d8d 61fcc3 E....Y].a.. …… 00000000 \u0026lt;func1\u0026gt;: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 08 sub $0x8,%esp 6: 8b 45 08 mov 0x8(%ebp),%eax 9: 89 44 24 04 mov %eax,0x4(%esp) d: c7 04 24 00 00 00 00 movl $0x0,(%esp) 14: e8 fc ff ff ff call 15 \u0026lt;func1+0x15\u0026gt; 19: c9 leave 1a: c3 ret 0000001b \u0026lt;main\u0026gt;: 1b: 8d 4c 24 04 lea 0x4(%esp),%ecx 1f: 83 e4 f0 and $0xfffffff0,%esp 22: ff 71 fc pushl -0x4(%ecx) 25: 55 push %ebp 26: 89 e5 mov %esp,%ebp 28: 51 push %ecx 29: 83 ec 14 sub $0x14,%esp 2c: c7 45 f4 01 00 00 00 movl $0x1,-0xc(%ebp) 33: 8b 15 04 00 00 00 mov 0x4,%edx 39: a1 00 00 00 00 mov 0x0,%eax 3e: 8d 04 02 lea (%edx,%eax,1),%eax 41: 03 45 f4 add -0xc(%ebp),%eax 44: 03 45 f8 add -0x8(%ebp),%eax 47: 89 04 24 mov %eax,(%esp) 4a[…] Contents of section .text”就是.text的数据以十六进制方式打印出来的内容，总共0x5b字节。.text段里所包含的正是SimpleSection.c里两个函数 func1() 和 main() 的指令。.text段的第一个字节“ 0x55 ”就是“ func1()” 函数的第一条“ push %ebp ”指令，而最后一个字节 0xc3 正是 main() 函数的最后一条指令“ ret ”。\n数据段和只读数据段 .data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面的SimpleSection.c代码里面一共有两个这样的变量，分别是 global_init_varabal 与 static_var 。这两个变量每个4个字节，一共刚好8个字节，所以“.data”这个段的大小为8个字节。\n.rodata”段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。单独设立“.rodata”段有很多好处，不光是在语义上支持了C++的const关键字，而且操作系统在加载的时候可以将“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。\nBSS 段 .bss段存放的是未初始化的全局变量和局部静态变量，如上述代码中 global_uninit_var 和 static_var2 就是被存放在.bss段，.bss段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间。\n其它段 除了.text、.data、.bss这3个最常用的段之外，ELF文件也有可能包含其他的段，用来保存与程序相关的其他信息： ELF文件结构 我们已经通过SimpleSection.o的结构大致了解了ELF文件的轮廓，接着就来看看ELF文件的结构格式。\n文件头 ELF目标文件格式的最前部是ELF文件头（ELF Header），它包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。紧接着是ELF文件各个段。其中ELF文件中与段有关的重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性（类似Macos 中的 Load Command 段）。接着将详细分析ELF文件头、段表等ELF关键的结构。另外还会介绍一些ELF中辅助的结构，比如字符串表、符号表等。\nELF文件头结构及相关常数被定义在“/usr/include/elf.h”里，因为ELF文件在各种平台下都通用，ELF文件有32位版本和64位版本。它的文件头结构也有这两种版本，分别叫做“Elf32_Ehdr”和“Elf64_Ehdr”。32位版本与64位版本的ELF文件的文件头内容是一样的，只不过有些成员的大小不一样。为了对每个成员的大小做出明确的规定以便于在不同的编译环境下都拥有相同的字段长度。\n文件头最开始的4个字节是所有ELF文件都必须相同的标识码，分别为0x7F、0x45、0x4c、0x46，第一个字节对应ASCII字符里面的DEL控制符，后面3个字节刚好是ELF这3个字母的ASCII码。这4个字节又被称为ELF文件的魔数，几乎所有的可执行文件格式的最开始的几个字节都是魔数。比如a.out格式最开始两个字节为 0x01、0x07；PE/COFF文件最开始两个个字节为0x4d、0x5a，即ASCII字符MZ。这种魔数用来确认文件的类型，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。\n接下来的一个字节是用来标识ELF的文件类的，0x01表示是32位的，0x02表示是64位的；第6个字是字节序，规定该ELF文件是大端的还是小端的（见附录：字节序）。第7个字节规定ELF文件的主版本号，一般是1，因为ELF标准自1.2版以后就再也没有更新了。后面的9个字节ELF标准没有定义，一般填0，有些平台会使用这9个字节作为扩展标志。\n段表 我们知道ELF文件中有很多各种各样的段，这个段表（Section Header Table）就是保存这些段的基本属性的结构。它描述了ELF的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。也就是说，ELF文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。\n段表的位置通过ELF的文件头“e_shoff”成员决定，比如SimpleSection.o中，段表位于偏移0x118。\n前文中我们使用了“objudmp -h”来查看ELF文件中包含的段，结果是SimpleSection里面看到了总共有6个段，分别是 “.code”、“.data”、“.bss ”、“. rodata ”、“. comment ”和“. note.GNU-stack ”。实际上的情况却有所不同，“objdump -h”命令只是把ELF文件中关键的段显示了出来，而省略了其他的辅助性的段，比如：符号表、字符串表、段名字符串表、重定位表等。我们可以使用readelf工具来查看ELF文件的段，它显示出来的结果才是真正的段表结构：\n$ readelf -S SimpleSection.o There are 11 section headers, starting at offset 0x118: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 00000000 000034 00005b 00 AX 0 0 4 [ 2] .rel.text REL 00000000 000428 000028 08 9 1 4 [ 3] .data PROGBITS 00000000 000090 000008 00 WA 0 0 4 [ 4] .bss NOBITS 00000000 000098 000004 00 WA 0 0 4 [ 5] .rodata PROGBITS 00000000 000098 000004 00 A 0 0 1 [ 6] .comment PROGBITS 00000000 00009c 00002a 00 0 0 1 [ 7] .note.GNU-stack PROGBITS 00000000 0000c6 000000 00 0 0 1 [ 8] .shstrtab STRTAB 00000000 0000c6 000051 00 0 0 1 [ 9] .symtab SYMTAB 00000000 0002d0 0000f0 10 10 10 4 [10] .strtab STRTAB 00000000 0003c0 000066 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)” 段表的结构比较简单，它是一个以“ Elf32_Shdr ”结构体为元素的数组。数组元素的个数等于段的个数，每个“ Elf32_Shdr ”结构体对应一个段。对于SimpleSection.o来说，段表就是有11个元素的数组。ELF段表的这个数组的第一个元素是无效的段描述符，它的类型为“NULL”，除此之外每个段描述符都对应一个段。也就是说SimpleSection.o共有10个有效的段。\n// 段表 结构体 内容 typedef struct{ Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize; } Elf32_Shdr; 对于编译器和链接器来说，主要决定段的属性的是段的类型（sh_type）和段的标志位（ sh_flags ）。\n段的类型（ sh_type ）:\n段的标志位（ sh_flag ） 段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。\n到了这一步，我们才彻彻底底把SimpleSection的所有段的位置和长度给分析清楚了。在图中，SectionTable长度为0x1b8，也就是440个字节，它包含了11个段描述符，每个段描述符为40个字节，这个长度刚好等于sizeof(Elf32_Shdr)，符合段描述符的结构体长度；整个文件最后一个段“.rel.text”结束后，长度为0x450，即1104字节，即刚好是SimpleSection.o的文件长度。中间Section Table和“.rel.text”都因为对齐的原因，与前面的段之间分别有一个字节和两个字节的间隔。\n重定位表 我们注意到，SimpleSection.o中有一个叫做“.rel.text”的段，它的类型（ sh_type ）为“ SHT_REL ”，也就是说它是一个重定位表（Relocation Table）。正如我们最开始所说的，链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。比如SimpleSection.o中的“.rel.text”就是针对“.text”段的重定位表，因为“.text”段中至少有一个绝对地址的引用，那就是对“printf”函数的调用；而“.data”段则没有对绝对地址的引用，它只包含了几个常量，所以SimpleSection.o中没有针对“.data”段的重定位表“.rel.data”。\n字符串表 ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串.\n一般字符串表在ELF文件中也以段的形式保存，常见的段名为“.strtab”或“.shstrtab”。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串，最常见的就是段名（ sh_name ）。\n链接的入口——符号 链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起，或者说像玩具积木一样，可以拼装形成一个整体。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。\n比如目标文件B要用到了目标文件A中的函数“foo”，那么我们就称目标文件A定义（Define）了函数“foo”，称目标文件B引用（Reference）了目标文件A中的函数“foo”。这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。\n每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录的就是目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号。\n对符号表中符号进行分类，它们有可能是下面这些类型中的一种：\n 定义在本目标文件的全局符号，可以被其他目标文件引用。比如SimpleSection.o里面的func1、main和global_init_var 。 在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），如SimpleSection.o引用的print函数。 段名，这种符号往往由编译器产生，它的值就是该段的起始地址。 局部符号，这类符号只在编译单元内部可见。比如SimpleSection.o里面的static_var和 static_var2 。这类符号链接器往往会忽略掉。 行号信息，即目标文件指令与源代码中代码行的对应关系。  对于链接过程中，重要的是全局符号，即上面的第一、第二种符号类型。在ELF文件中的符号表往往是文件中的一个段，段名一般叫“.symtab”。符号表的结构很简单，它是一个Elf32_Sym结构（32位ELF文件）的数组，每个Elf32_Sym结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的“未定义”符号。Elf32_Sym的结构定义如下：\ntypedef struct { Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx; } Elf32_Sym; 符号所在段（ st_shndx ）如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号可以参考下表：\n符号值（ st_value ）根据st_shndx 不同含义也不相同。在目标文件中，如果是符号的定义并且该符号不是“COMMON块”类型的，则st_value表示该符号在段中的偏移。即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。比如SimpleSection.o中的“ func1 ”、“ main ”和“ global_init_var ”。在目标文件中，如果符号是“COMMON块”类型的（即 st_shndx 为SHN_COMMON），则st_value表示该符号的对齐属性。在可执行文件中，st_value表示符号的虚拟地址。这个虚拟地址对于动态链接器来说十分有用。\n符号修饰和函数签名 早起程序编程时，编译器编译源代码产生目标文件时，符号名与相应的变量和函数的名字是一样的，这就导致源代码和现存的库不可避免的出现命名冲突的问题。为了防止类似的符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线“_”。\n更为复杂的C++中拥有类、继承、虚机制、重载、名称空间等这些特性，它们使得符号管理更为复杂。最简单的例子，两个相同名字的函数func(int)和func(double)。编译器为了要区分两个同名但参数不一致的函数引入了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制。\n在此之前我们需要了解一个术语叫做函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数签名用于识别不同的函数，就像签名用于识别不同的人一样，函数的名字只是函数签名的一部分。函数签名就是符号修饰的必要条件。当我们知道了一个函数的签名我们就通过函数签名推出函数的真正的符号名。如下列代码6个同名函数 fun在 GCC编译器下产生的不同符号名：\n签名和名称修饰不仅针对函数，C++中的全局变量和静态变量也有同样的机制。编译的规则大家可以查阅相关文档，不同的编译器厂商的名称修饰方法可能不同，所以不同的编译器对于同一个函数签名可能对应不同的修饰后名称。\n强符号与弱符号 在编程中我们总会碰到的一种情况叫做符号重复定义。那么这些目标文件链接的时候将会出现符号重复定义的错误。比如我们在目标文件A和目标文件B都定义了一个全局整形变量global，并将它们都初始化，那么链接器将A和B进行链接时会报错：\nb.o:(.data+0x0): multiple definition of `global' a.o:(.data+0x0): first defined here 这种符号的定义可以被称为强符号（Strong Symbol）。有些符号的定义可以被称为弱符号（Weak Symbol）。对于C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。我们也可以通过GCC的 “attribute((weak))” 来定义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用。比如我们有下面这段程序：\n extern int ext; // 外部变量引用，无强弱之分 int weak; // 弱符号 int strong = 1; // 强符号 __attribute__((weak)) weak2 = 2; // 弱符号 int main(){ // 记住 main 也是强符号 return 0; } 强、弱符号规则：\n 不允许强符号被多次定义（即不同目标文件不能有同名强符号）。 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。  弱引用和强引用 目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。\n弱引用（Weak Reference），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。\n// 声明一个弱引用，链接器默认为0 __attribute__ ((weakref)) void foo(); int main(){ // 编译器不会认为它是一个错误。链接不会报错，只有当它执行的时候调用`foo`函数函数时，地址为0，产生非法地址访问 foo(); } ",
    "ref": "/blog/link_load3/"
  },{
    "title": "读《程序员的自我修养-链接、装载与库》—— 编译和链接",
    "date": "",
    "description": "",
    "body": "编译和链接 被隐藏了的过程 在开发过程中我们主要的开发环境都是流行的继承开发环境（IDE），如 Visual Studio、Xcode、等。IDE将编译和链接的过程一步完成（通常称之为构建 | Build）。这一过程都被隐藏在了代码程序的下层。\n我们以C 语言入门级程序 hello.c为例：\n#include \u0026quot;stdio.h\u0026quot; int main() { printf(\u0026quot;Hello World\\n\u0026quot;); return 0; } 我们可以使用 gcc 最简单的命令进行编译\n$gcc hello.c $./a.out Hello World 事实上，上述过程分为4个步骤分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。\n预处理阶段 第一步预编译的过程相当于如下命令（-E表示只进行预编译）：\ngcc -E hello.c -o hello.i 预编译工作是处理以**\u0026quot;#\u0026quot;**开头的预编译指令，如#include、#import、#define等，主要规则如下：\n 将所有#define删除，展开替换所有的宏定义。 处理所有条件预编译指令，如#if、#ifdef、#elif、#else、#endif。 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。（递归进行，如果文件还包含其他文件也会被一起插入） 删除所有的注释，如 //,/** */等 添加行号、和文件名标识,如# 10 \u0026quot;hello.c\u0026quot; 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器会使用它们  编译阶段 编译的过程是一系列的 词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这块是整个程序构建的核心，也是最复杂的部分，但不是本书的重点，所以只会介绍一些基本内容。下面是编译代码的命令：\ngcc -S hello.i -o hello.s 或者直接通过\ngcc -S hello.c -o hello.s 都可以得到汇编输出的文件hello.s,对于C语言来说，预编译和编译的程序是cc1，对于C++是c11plus，Objective-C 是 cc1obj等。\n汇编阶段 汇编器是将汇编代码转换为机器可以执行的指令，每条汇编语句几乎都对应一条机器指令。所以汇编器的过程相对于编译器的过程相对来说比较简单。\nas hello.s -o hello.o 或者直接从源代码开始直接输出目标文件.o\nas hello.c -o hello.o 链接阶段 链接是一个比较让人费解的过程，为什么汇编器输入的是目标文件而不是直接输出可执行文件，链接过程需要包含什么内容？为什么需要链接？这些问题需要我们学到后面才能知晓，先来看看如何链接当前的目标文件 hello.o 吧（Mac上运行gcc编译器好像指向的clang下面命令行中路径都不存在无法运行成功\u0026hellip;.先跳过吧）。\nld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/ crtbeginT.o -L/usr/lib/gcc/i486-linux-gnu/4.1.3 -L/usr/lib -L/lib hello.o -- start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/ crtend.o /usr/lib/crtn.o 可以看到，我们需要将一大堆文件链接起来才可以得到可以最终执行的.o文件。可能很多读者的疑惑更多了，crt1.o、crti.o、crtbeginT.o、crtend.o、crtn.o这些文件是什么？它们做什么用的 ？-lgcc –lgcc_eh –lc 这些都是什么参数？为什么要使用它们？为什么要将它们和hello.o链接起来才可以得到可执行文件？等等。 关于这些问题的答案，正式这本书的内容，所以需要我们将整本书读完才会有一个完整答案，而非一蹴而就的得到一个似是而非的答案。\n编译器 编译器做了什么 从最直观的角度出发，编译器就是将高级语言翻译成机器语言的一个工具。比如我们使用 C/C++ 语言写的一个程序可以通过编译器将其翻译成机器可以执行的指令和数据。\n编译的过程一般分为6步：\n 扫描(词法分析) 语法分析 语义分析 源代码优化 代码生成 目标代码优化  还是以 C 语言的源代码为例：\narray[index] = (index + 4) * (2 + 6) 扫描 经过扫描器扫描后（词法分析）将源代码的字符序列分割成一系列的记号（Token）。比如上面这行程序总共包含28个非空字符串，经扫描后，产生16个记号：\n   记号 类型     array 标识符   [ 左方括号   index 标识符   ] 右方括号   = 赋值   （ 左圆括号   index 标识符   + 加号   4 数字   ) 右圆括号   * 乘号   （ 左圆括号   2 数字   + 加号   6 数字   ) 右圆括号    词法分析产生的一般可以分为：关键字、标识符、字面量（数字、字符串等）和特殊符号（+、=）。在设别记号的同事，扫描器也会将标识符存放到符号表、将数字、字符串常量存放到文字表，以备后面使用。\n语法分析 接下来是语法分析器对扫描器产生的记号进行语法分析，从而产生语法树（syntax tree）。简单的将语法分析就是以表达式（Expression）为节点的树。\n在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。比如乘法表达式的优先级比加法高，而圆括号表达式的优先级比乘法高，等等。另外有些符号具有多重含义，比如星号*在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，所以语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。\n语义分析 由语义分析器（Semantic Analyzer）来完成。语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。比如C语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的；比如同样一个指针和一个浮点数做乘法运算是否合法等。编译器所能分析的语义是静态语义（Static Semantic），所谓静态语义是指在编译期可以确定的语义，与之对应的动态语义（Dynamic Semantic）就是只有在运行期才能确定的语义。上面描述的语法树在经过语义分析阶段以后成为如图: 中间语言生成 现代的编译器有着很多层次的优化，往往在源代码级别会有一个优化过程。我们这里所描述的源码级优化器（Source Code Optimizer）在不同编译器中可能会有不同的定义或有一些其他的差异。源代码级优化器会在源代码级别进行优化，在上例中，细心的读者可能已经发现，（2 + 6）这个表达式可以被优化掉，因为它的值在编译期就可以被确定。类似的还有很多其他复杂的优化过程，我们在这里就不详细描述了。经过优化的语法树如图所示。\n我们看到（2 + 6）这个表达式被优化成8。其实直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），它是语法树的顺序表示，其实它已经非常接近目标代码了。但和目标机器和运行时环境无关。\n中间代码有很多形式常见的有三地址码（Three-address Code）和P-代码（P-Code）。我们就拿最常见的三地址码来作为例子，最基本的三地址码是这样的:\nx = y op z 这个三地址码表示将变量y和z进行op操作以后，赋值给x。这里op操作可以是算数运算，比如加减乘除等，也可以是其他任何可以应用到y和z的操作。三地址码也得名于此，因为一个三地址码语句里面有三个变量地址。我们上面的例子中的语法树可以被翻译成三地址码后是这样的：\nt1 = 2 + 6 t2 = index + 4 t3 = t2 * t1 array[index] = t3 优化程序会计算出t1=8，然后将后面的t1替换成8，因为t2可以重复利用，还可以省去一个临时变量t3，经过优化后的代码\nt2 = index + 4 t2 = t2 * 8 array[index] = t2 中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。\n目标代码的生成及优化 源代码级优化器产生中间代码标志着下面的过程都属于编辑器后端。编译器后端主要包括代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）。\n代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于上面例子中的中间代码，代码生成器可能会生成下面的代码序列（我们用x86的汇编语言来表示，并且假设index的类型为int型，array的类型为int型数组）：\nmovl index, %ecx ; value of index to ecx addl $4, %ecx ; ecx = ecx + 4 mull $8, %ecx ; ecx = ecx * 8 movl index, %eax ; value of index to eax movl %ecx, array(,eax,4) ; array[index] = ecx 最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上面的例子中，乘法由一条相对复杂的基址比例变址寻址（Base Index Scale Addressing）的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。\nmovl index, %edx leal 32(,%edx,8), %eax movl %eax, array(,%edx,4) 经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题是：index和array的地址还没有确定。如果我们要把目标代码使用汇编器编译成真正能够在机器上执行的指令，那么index和array的地址应该从哪儿得到呢？如果index和array定义在跟上面的源代码同一个编译单元里面，那么编译器可以为index和array分配空间，确定它们的地址；那如果是定义在其他的程序模块呢？\n定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。让我们带着这个问题，走进链接的世界。\n链接器 在现代软件开发过程中，软件的规模往往都很大，动辄数百万行代码，如果都放在一个模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。\n分割成多个模块之后，模块之间的如何组合的问题就是我们链接所着重解决的问题。最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的函数调用，另外一种是模块间的变量访问。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间符号的引用。\n模块的拼装——静态链接 程序设计的模块化是人们一直在追求的目标，因为当一个系统十分复杂的时候，我们不得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。一个复杂的软件也如此，人们把每个源代码模块独立地编译，然后按照需要将它们“组装”起来，这个组装模块的过程就是链接（Linking）。\n链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。\n符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）。\n大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。\n我们在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。\n以上是一个最基本的静态链接过程，每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj），目标文件和库（Library）一起链接.\n",
    "ref": "/blog/link_load2/"
  },{
    "title": "读《程序员的自我修养-链接、装载与库》—— 基础知识",
    "date": "",
    "description": "",
    "body": "基础知识 计算机是个非常广泛的概念，大到占用数层楼的用于科学计算的超级计算机，小到手机上的嵌入式芯片都可以被称为计算机。撇开计算机硬件中纷繁复杂的各种设备、芯片及外围接口等，站在软件开发者的角度看，我们只须抓住硬件的几个关键部件。对于系统程序开发者来说，计算机多如牛毛的硬件设备中，有三个部件最为关键，它们分别是中央处理器CPU、内存和I/O控制芯片，这三个部件几乎就是计算机的核心了。\n通过了解计算机核心的三个部件，我们可以大致的了解计算机运行原理，\n中央处理器CPU 早期的计算机没有很复杂的图形功能，CPU的核心频率也不高，人们首先针对 CPU 的频率进行升级，从 几十 KHz 升级到现在的 4GHz，达到了目前工艺的物理极限。之后开始从数量上提升，增加 CPU 的数量。其中最常见的就是对称多处理器 SMP（Symmetrical Multi-Processing）。目前个人电脑使用多核处理器就是SMP的简化版。\n系统软件传统意义上一般将用于管理计算机本身的软件成为系统软件。系统软件又可分成两块，一块是平台性的，比如操作系统内核、驱动程序、运行库和数以千计的系统工具；另外一块是用于程序开发的，比如编译器、汇编器、链接器等开发工具和开发库。\n早期 CPU 资源十分为了进一步利用 CPU 资源，所以引入了操作系统，由操作系统接管所有的硬件资源，应用程序则以进程的方式运行，每个进程都有自己独立的地址空间，进程之间地址空间相互隔离，CPU 由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但是，如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU的分配方式即所谓的抢占式（Preemptive），如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，从而造成了很多进程都在同时运行的假象。目前几乎所有现代的操作系统都是采用这种方式，比如我们熟悉的UNIX、Linux、Windows NT，以及Mac OS X等流行的操作系统。\nI/O控制 操作系统位于硬件的上层，是对硬件的管理和抽象。作为应用开发程序员我们不用去关心底层的硬件到底是如何工作的，我们只需要调用操作系统统一的API来完成我们的开发任务。在UNIX中，硬件设备的访问形式跟访问普通的文件形式一样；在Windows系统中，图形硬件被抽象成了GDI，声音和多媒体设备被抽象成了DirectX对象；磁盘被抽象成了普通文件系统。操作系统开发者提供一系列的接口和框架，具体硬件的驱动程序则交由硬件产商实现。\n磁盘驱动程序收到这个读取文件请求以后就向硬盘发出硬件命令。向硬件发送I/O命令的方式有很多种，其中最为常见的一种就是通过读写I/O端口寄存器来实现。\n内存 在早期的计算机中，程序是直接运行在物理内存上的，但随着计算机的发展，为了更好的利用硬件资源。我们必须同时运行程序，那么如何分配有限的物理内存给多个程序使用。\n为了更好的利用内存资源，我们增加了中间层，即使用一种间接的地址访问方法。整个想法是这样的，我们把程序给出的地址看作是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程的隔离。\n目前虚拟内存通过分页（Paging）来进行物理内存和虚拟内存的映射，分页的基本方法是把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。\n多线程 对于多线程，我们需要了解下线程的概念、线程的调度、线程安全、用户线程与内核线程之间的映射关系。\n线程（Thread），有时被称为轻量级进程（Lightweight Process, LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。\n线程状态包括：运行、就绪、等待。\n在单处理器对应多线程的情况下，并发是一种模拟出来的状态。在每个线程切换执行我们称之为线程调度。处于运行中线程拥有一段可以执行的时间，这段时间称为时间片（Time Slice），当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生之后，该线程将进入就绪状态。 多个线程同时访问一个共享数据，就有可能造成“脏数据”,下面的代码执行结果可能是0、1、2。\n// 线程1 i = 1; i++; // 线程2 --i; 为了保证数据的安全。我们需要将各个线程对同一个数据的访问同步（Synchronization）。所谓同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。\n锁 同步最常用的方法就是加锁（LOCK），锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取（Acquire）锁，并在访问结束之后释放（Release）锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。\n信号量 二元信号量（Binary Semaphore）是最简单的一种锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。（iOS中的 dispatch_semaphore_t）\n互斥锁 互斥量（Mutex）和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的。（ pthread_mutex ）\n读写锁 读写锁（Read-Write Lock）致力于一种更加特定的场合的同步。主要针对一些多度单写的情况。读取数据并不会造成数据的不安全。线程可以同时读取数据。只要发生写时才需要锁。对于同一个锁，读写锁有两种获取方式，共享的（Shared）或独占的（Exclusive）。当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。然而，如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。相应地，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。（pthread_rwlock、iOS 可以通过dispatch_barrier_async 实现类似功能）\n条件锁 条件变量（Condition Variable）作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。（iOS 中的NSConditionLock）\n编译器的过渡优化 有时候编译器会对代码进行优化：1.调整代码执行顺序、2.为了提高变量访问速度，将变量缓存到寄存器中而不写回。这就会造成多线程代码执行错误。\n// 有时候编译器会将寄存器中的x值缓存起来，线程2读取内存中的x值还是 0，有可能导致最终 // x 的结果为1 x =0 // 线程1 lock() x ++; unlock() // 线程2 lock() x ++; unlock() 我们可以使用volatile关键字试图阻止过度优化，volatile基本可以做到两件事情：\n 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。 阻止编译器调整操作volatile变量的指令顺序。  ",
    "ref": "/blog/link_load/"
  },{
    "title": "【译】Flutter动画系列——显示动画",
    "date": "",
    "description": "",
    "body": "在Flutter 动画详解系列——隐式动画中我们介绍了Flutter中的隐式动画，隐式动画创建简单、灵活性差，而显式动画相对来说更加灵活。接下来让我们来看看 Flutter 中的显式动画。\nFlutter内置显示动画FooTransition（Foo代表动画需要改变的属性值） 先来看一张图，下面列出了部分Flutter中内置的显式动画Widget： 我们可以通过直接使用上述的Widget，来创建显示动画，让我们以RotationTransition为例来看看显式动画如何创建。\nRotationTransition Demo // RotationTransition 构造器 RotationTransition({ Widget child, Alignment alignment, Animation\u0026lt;double\u0026gt; turns, }) child 指定哪个widget用来做旋转动画，alignment是坐标系原点的对齐方式，我们想要有银河星系的旋转效果使用center作为坐标系原点。turns：在API文档中定义是Animation抽象类型，turns是显示动画有别于隐式动画的的重要参数。我们使用隐式动画Widget AnimatedContainer 更改transform也能达到图片旋转的效果，但是隐式动画只会执行一次便会停止。借助于显式动画，我们不仅可以控制动画时间长，并可以让动画一直重复执行。\n创建AnimationController AnimationController 顾名思义，是用来控制动画，AnimationController 继承自抽象类Animation\u0026lt;double\u0026gt;,AnimationController 可以监听动画的执行、还能提供一些动画的控制操作。\nclass _TimeMachineState extends State\u0026lt;TimeMachine\u0026gt; { AnimationController _animationController; @override void initState() { super.initState(); _animationController = AnimationController( // ... ); } @override void dispose() { _animationController.dispose(); super.dispose(); } } AnimationController 需要传递两个必要参数，duration 即我们动画的执行时间，默认 AnimationController 在给定的时间段内会线性的生成从0.0到1.0的数字。而具体值的数量和粒度取决于之前的duration参数。设置 vsync 时用来防止屏幕外动画（动画的UI不在当前屏幕时）消耗不必要的资源。 通过将SingleTickerProviderStateMixin添加到类定义中，可以将stateful对象作为vsync的值。\nclass _TimeMachineState extends State\u0026lt;TimeMachine\u0026gt; with SingleTickerProviderStateMixin { AnimationController _animationController; @override void initState() { super.initState(); _animationController = AnimationController( duration: Duration(seconds: 15), vsync: this, ); } @override void dispose() { _animationController.dispose(); super.dispose(); } } 当我们创建完AnimationController后，不要忘记开启动画:\n_animationController = AnimationController( duration: Duration(seconds: 15), vsync: this, )..repeat(); 最后，我们回到上面 RotationTransition 银河旋转动画效果的代码部分，补充完turns参数。\nRotationTransition( child: GalaxyFitz(), alignment: Alignment.center, turns: _animationController, ) 同时，我们也可以通过_animationController来对动画进行控制,如下我们添加了一个100的正方形手势，来暂停、开启动画效果。\nclass TimeStopper extends StatelessWidget { final AnimationController controller; const TimeStopper({Key key, this.controller}) : super(key: key); @override Widget build(BuildContext context) { return GestureDetector( onTap: () { if (controller.isAnimating) { controller.stop(); } else { controller.repeat(); } }, child: Container(color: Colors.red,width: 100,height: 100,), ); } } 小结 相对于隐式动画，显式动画需要一个动画的控制器，我们知道了在Flutter中存在内置的显示动画效果FooTransition。我们可以通过设置 duration 、和 AnimationController 来创建一个重复循环的动画效果，并且我们可以通过 AnimationController 来控制动画。那么当系统自带的显式动画Widget无法满足我们时，我们就需要创建自定义的显式动画啦。\n使用AnimatedBuilder和AnimatedWidget创建自定义显式动画 为了更加具体的了解AnimatedBuilder和AnimatedWidget，我们编写一个外星飞船的动画demo，动画效果是飞船的传输光线。\n首先自定义一个Path剪切器，形成光束的形态。\nimport 'package:flutter/material.dart'; void main() =\u0026gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( body: MyHomePage(), )); } } class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return Stack( alignment: AlignmentDirectional.center, children: \u0026lt;Widget\u0026gt;[ ClipPath( clipper: const BeamClipper(), child: Container( height: 1000, decoration: BoxDecoration( gradient: RadialGradient( radius: 1.5, colors: [ Colors.yellow, Colors.transparent, ], ), ), ), ), ], ); } } class BeamClipper extends CustomClipper\u0026lt;Path\u0026gt; { const BeamClipper(); @override getClip(Size size) { return Path() ..lineTo(size.width / 2, size.height / 2) ..lineTo(size.width, size.height) ..lineTo(0, size.height) ..lineTo(size.width / 2, size.height / 2) ..close(); } /// Return false always because we always clip the same area. @override bool shouldReclip(CustomClipper oldClipper) =\u0026gt; false; } 接下来就可通过AnimatedBuilder和 AnimatedWidget 来实现动画效果了。\nAnimatedBuilder class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =\u0026gt; _MyHomePageState(); } class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; with SingleTickerProviderStateMixin { final Image starsBackground = Image.asset( 'assets/milky-way.jpg', ); final Image ufo = Image.asset('assets/ufo.png'); AnimationController _animation; @override void initState() { super.initState(); _animation = AnimationController( duration: const Duration(seconds: 5), vsync: this, )..repeat(); } @override Widget build(BuildContext context) { return Stack( alignment: AlignmentDirectional.center, children: \u0026lt;Widget\u0026gt;[ starsBackground, AnimatedBuilder( animation: _animation, builder: (_, __) { return ClipPath( clipper: const BeamClipper(), child: Container( height: 1000, decoration: BoxDecoration( gradient: RadialGradient( radius: 1.5, colors: [ Colors.yellow, Colors.transparent, ], stops: [0, _animation.value], ), ), ), ); }, ), ufo, ], ); } @override void dispose() { _animation.dispose(); super.dispose(); } } class BeamClipper extends CustomClipper\u0026lt;Path\u0026gt; { const BeamClipper(); @override getClip(Size size) { return Path() ..lineTo(size.width / 2, size.height / 2) ..lineTo(size.width, size.height) ..lineTo(0, size.height) ..lineTo(size.width / 2, size.height / 2) ..close(); } /// Return false always because we always clip the same area. @override bool shouldReclip(CustomClipper oldClipper) =\u0026gt; false; } 跟之前Flutter 系统内置的显式动画一样，我们需要创建一个动画控制器、混入 SingleTickerProviderStateMixin 防止屏幕外动画。\n之前在介绍 TweenAnimationBuilder 文章中提到过，在设置 child 参数的时候，如果在动画过程中 child 不会变动，我们可以提前构建它，然后将其传递给AnimatedBuilder。在这个例子中，BeamClipper 可以提供一个常量的构造函数生成常量对象，用于优化动画的性能。\nAnimatedWidget 使用 AnimatedBuilder 代码构建出来的动画效果，可能代码有点臃肿，难以阅读。此时我们可以尝试创建一个 AnimatedWidget 的子类，来完成同样的动画效果。与系统的内置显式动画效果命名一致，推荐FooTransition的命名原则。这里我们将其命名为BeamTransition，\nclass MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =\u0026gt; _MyHomePageState(); } class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; with SingleTickerProviderStateMixin { final Image starsBackground = Image.asset( 'assets/milky-way.jpg', ); final Image ufo = Image.asset('assets/ufo.png'); AnimationController _animation; @override void initState() { super.initState(); _animation = AnimationController( duration: const Duration(seconds: 5), vsync: this, )..repeat(); } @override Widget build(BuildContext context) { return Stack( alignment: AlignmentDirectional.center, children: \u0026lt;Widget\u0026gt;[ starsBackground, BeamTransition(animation: _animation), ufo, ], ); } @override void dispose() { _animation.dispose(); super.dispose(); } } class BeamTransition extends AnimatedWidget { BeamTransition({Key key, Animation\u0026lt;double\u0026gt; animation}) : super(key: key, listenable: animation); @override Widget build(BuildContext context) { final Animation\u0026lt;double\u0026gt; animation = listenable; return ClipPath( clipper: const BeamClipper(), child: Container( height: 1000, decoration: BoxDecoration( gradient: RadialGradient( radius: 1.5, colors: [ Colors.yellow, Colors.transparent, ], stops: [0, animation.value], ), ), ), ); } } 我们将上面AnimatedBuilder中build的方法替换了下。将创建动画的代码抽取到了BeamTransition中。注意在BeamTransition中 child 中不变部分的我们使用常量值。\n总结 到此，Flutter 中显式动画的介绍也告一段落了，显式动画能够循环的执行下去、并且通过动画控制器我们可以轻松的控制动画。在自定义显式动画时，比较推荐使用 AnimatedWidget 单独的抽取成一个独立的Widget。当然如果动画足够简单，使用 AnimatedBuilder 不会造成代码阅读的困难的话，也可以是用AnimatedBuilder。\n",
    "ref": "/blog/flutter_animation_explict/"
  },{
    "title": "【译】Flutter动画系列——隐式动画",
    "date": "",
    "description": "",
    "body": "上一篇文章【译】FLUTTER 动画系列—初篇，概述了下Flutter中的动画类型，及如何选择恰当的动画创建方式，接下来我们来看下最简单的动画，隐式动画。\n系统的隐式动画Widget 在 Flutter 中的 Widgets 中有一部已经实现隐式动画Widget。如下图列出部分：\n首先我们来看一段未使用动画的代码：\n bool _bigger = false; @override Widget build(BuildContext context) { return Scaffold( body: Column( mainAxisAlignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ Center( child: Container( width: _bigger ? 100 : 500, height: 100, color: Colors.red, ), ), RaisedButton( onPressed: () =\u0026gt; setState(() { _bigger = !_bigger; }), child: Icon(Icons.star), ), ], ), ); } 未加动画效果时，矩形的形变会显得十分生硬，如果使用AnimatedContainer替换Container，增加一个动画的过渡效果：\n Center( child: AnimatedContainer( width: _bigger ? 100 : 500, height: 100, color: Colors.red, duration: Duration(seconds: 1), ), ), 整个过渡过程显得比较自然顺畅，我们通过新旧值之间的值进行动画处理的过程称为插值。每当旧值和新值发生变化时，AnimatedContainer便会处理其属性插值。\n同样我们也可以通过插值来修改AnimatedContainer的其它属性，包括decoration 的渐变色:\nAnimatedContainer( decoration: BoxDecoration( gradient: RadialGradient( colors: [Colors.purple, Colors.transparent], stops: [ _bigger ? 0.2 : 0.5, 1.0]) ), ), 上述代码很简单的演示如何使用 隐式动画Widget 来实现动画效果，非常的方便简单，但这也意味着可灵活性较差，在隐式动画Widget中，我们控制动画效果只能控制动画时长（Duration）和动画的曲线（Curve,具体的曲线效果可以参考 系统自带的曲线效果）。\nAnimatedContainer( width: _bigger ? 100 : 500, child: Image.asset('assets/star.png'), duration: Duration(seconds: 1), curve: Curves.easeInOutQuint, ), 另外除了系统自带的曲线效果外，我们还可以通过继承Curve来实现自定义的曲线效果,如下实现了正弦曲线。\nclass SineCurve extends Curve { final double count; SineCurve({this.count = 1}); @override double transformInternal(double t) { return sin(count * 2 * pi * t) * 0.5 + 0.5; } } 小结 在Flutter中，系统已经提供了隐式动画的Widget，这些Widget是普通Widget的动画版本，我们可以通过 duration、curve来控制动画效果。\n还有我们不一定需要通过StatefulWidget中使用setState来生成动画效果，我们也可以使用StreamBuilder和FutureBuilder来触发动画。\nFutureBuilder( future: future, builder: (BuildContext context, AsyncSnapshot\u0026lt;String\u0026gt; snapshot) { double width; switch(snapshot.connectionState) { case ConnectionState.none: case ConnectionState.waiting: case ConnectionState.active: width = 0; break; case ConnectionState.done: width = 500; break; } return AnimatedContainer( width: width, height: 100, color: Colors.red, duration: Duration(seconds: 1), ); } ), 以上，如果Flutter框架提供给你的隐式动画Widget不能满足你的需求，那么进一步的话可以试试使用TweenAnimationBuilder 来自定义创建隐式动画。\n自定义隐式动画TweenAnimationBuilder 使用TweenAnimationBuilder，该 Widget 使用的时候我们需要传递 duration 参数动画时间、tween 参数动画要设置的值的范围（补间）、重要的还有 builder 参数，builder函数的参数包含context、补间参数tween的类型、还有child,让我们看一个简单的例子，红色的矩形框旋转360度：\nTweenAnimationBuilder\u0026lt;double\u0026gt;( tween: Tween\u0026lt;double\u0026gt;(begin: 0, end: 2 * pi), duration: Duration(seconds: 2), builder: (BuildContext context, double angle, Widget child) { return Transform.rotate( angle: angle, child: Container( color: Colors.red, width: 100, height: 100, ), ); }, ), 让我们再来看个例子，使用ColorFilered Wideget做一个图片渲染的效果。\nTweenAnimationBuilder( tween: ColorTween(begin: Colors.white, end: Colors.red), duration: Duration(seconds: 2), builder: (_, Color color, __) { return ColorFiltered( child: Image.asset('assets/sun.png'), colorFilter: ColorFilter.mode(color, BlendMode.modulate), ); }, ) 通过Tween补间参数设置了从白色到红色的过渡，由颜色和图片的混合，另外如何补间参数可变的，所以如果补间参数是不变的话可以将参数声明为静态常量来使用。\nstatic final colorTween = ColorTween(begin: Colors.white, end: Colors.red); Center( child: TweenAnimationBuilder\u0026lt;Color\u0026gt;( tween: colorTween, duration: Duration(seconds: 2), builder: (_, Color color, __) { return ColorFiltered( child: Image.asset('assets/sun.png'), colorFilter: ColorFilter.mode(color, BlendMode.modulate), ); }, ), ), 动态修改 Tween 参数 上面的例子中我们并没有调用setState，仅仅展示了动画从Tween的初始值到终值的简单动画效果，除此之外，我们还可以通过动态的修改Tween来实现动画效果：\nclass OngoingAnimationByModifyingEndTweenValue extends StatefulWidget { @override _OngoingAnimationState createState() =\u0026gt; _OngoingAnimationState(); } class _OngoingAnimationState extends State\u0026lt;OngoingAnimationByModifyingEndTweenValue\u0026gt; { double _newValue = .4; Color _newColor = Colors.white; @override Widget build(BuildContext context) { return Stack( children: \u0026lt;Widget\u0026gt;[ starsBackground, Column( children: \u0026lt;Widget\u0026gt;[ Center( child: TweenAnimationBuilder( tween: ColorTween(begin: Colors.white, end: _newColor), duration: Duration(seconds: 2), builder: (_, Color color, __) { return ColorFiltered( child: Image.asset('assets/sun.png'), colorFilter: ColorFilter.mode(color, BlendMode.modulate), ); }, ), ), Slider.adaptive( value: _newValue, onChanged: (double value) { setState(() { _newValue = value; _newColor = Color.lerp(Colors.white, Colors.red, value); }); }, ), ], ), ], ); } } 首先我们声明一个_newColor  作为 Tween 的终值,通过滑动 Slider Widget，我们改变_newColor。调用setState每次的滑动都会使得动画更新。\n另外，需要明确的一点事，TweenAnimationBuilder 的动画属性值是从当前值向最新的终值转变的。如上面的例子，当我们拖动 Slider 时，颜色变化相对于之前的颜色,而不是每次从最初的白色开始动画渐变。\nTweenAnimationBuilder 总会将当前颜色到终值颜色平滑的动画过渡。所以如果改变的不是终值颜色而是开始颜色，动画效果是不会有区别的。\n补充说明 除了上诉介绍的TweenAnimationBuilder参数外，我们还需要注意的参数还有：\n curve，动画曲线，在上一篇文章Flutter 动画详解系列有过介绍。 动画完成的回调 onEnd :，我们可以在动画完成时完成指定的操作，如动画完成后显示另一个Widget。 child参数，child参数的设置其实也是一个潜在的性能优化项，正确的设置child，对动画性能的提升也是一大帮助。例子中虽然颜色发生了变化，但图片本身保持不变，但是当前代码是每次build都会重新创建Image Widget。针对此类的优化方式，我们可以提前创建图片，将图片作为参数传入，这样 Flutter 就知道每帧渲染时变化的是颜色，而不是图片本身。 当然因为例子本身简单，所以此优化不会有明显的效果，但当实现复杂动画效果时，慎重考虑child的实现，将会对你的动画性能带来一定的帮助。  总结 OK，以上就是对 Flutter 中的隐式动画的介绍了，包括系统自带的AnimatedFoo和TweenAnimationBuilder 都有了一定的涉及。包括如何不通过使用StatefulWidget来实现动画效果、如何改变tween的终值产生顺滑的动画效果、如何提升TweenAnimationBuilder 的动画性能时，我们可以设置tween参数时可以考虑设置为静态常量，设置child参数时可以考虑提前创建好child，作为参数传递。\n",
    "ref": "/blog/flutter_animation_implict/"
  },{
    "title": "【译】Flutter 动画系列——初篇",
    "date": "",
    "description": "",
    "body": " 前言：动画会让用户界面感觉更直观、流畅，能改善用户体验。 在Flutter中我们可以轻松实现各种动画类型。目前Flutter中很多 widget（特别是Material Design widgets），都实现了设计规范中定义的标准动画效果。但是我们也可以自定义这些动画效果。\n Flutter中动画的类型 在Flutter中动画分为两类： 基于图形动画（以图形的形式制作动画，三方库 Rive 、Lottie）、基于代码动画 （主要针对于 Widgets 的大小、 颜色、形状变动）。文章主要讲解基于代码动画类型的动画。\n基于代码动画 在 Flutter 中基于代码动画，也主要分为两种形式：补间(Tween)动画、 拟物动画。\n补间(Tween)动画 Tween意为在两者之间，在Tween动画中我们定义开始点和结束点、时间线以及定义转换时间和速度的曲线。然后就交由框架完成如何从开始点过渡到结束点的动画效果。\n拟物动画 拟物动画是对真实世界的行为进行建模，使动画效果类似于现实中的物理效果。例如当你掷球时，它在何处落地，取决于抛球速度有多快、球有多重、距离地面有多远。\n如何创建恰当的动画 在知道 Flutter 的动画类型之后，我们需要知道如何创建我们想要的动画效果，在 Flutter 动画也被分为隐式动画、 显示动画。当我们创建一个动画效果时，如果你不知道如何选择这两种方式，你可以试着回答下面的三个问题：\n  动画效果是否\u0026quot;永远\u0026quot;重复？永远是指某个条件下动画一直重复，当条件变动时，动画可以停止。\n  动画的值是否不连续？如下图圆从小到大、从小到大，并未连续的小-\u0026gt;大-\u0026gt;小-\u0026gt;大。   动画是否由多个Widgets共同组成？   如果以上三个问题，都是肯定的回答，那么你需要的是显示动画，否则使用隐式动画将会是你更好的选择。\n隐式动画 如果你选择了隐式动画之后，首先你可以尝试在 Flutter 框架中寻找符合你要求的 Widgets，Flutter 对隐式动画的命名方式一般为 AnimatedFoo， 其中 Foo 是需要设置动画的属性。如果找不到符合自己需求的内置动画Widget，我们可以使用 TweenAnimationBuilder（补间动画生成器）创建自定义的隐式动画。\n显示动画 如果你的选择是显示动画，那么你也可以尝试在 Flutter 框架中寻找符合 Widgets。Flutter 对显示动画的命名方式一般为FooTransition， 其中 Foo 是需要设置动画的属性（如SlideTransition）。如果找不到符合自己需求的内置动画Widget。你还有两种选择，创建独立的动画Widget（扩展AnimatedWidget），或者扩展Widget（使用AnimatedBuilder）。\n如果在动画执行的过程中，碰到了性能的问题的话，我们可以考虑使用CustomPainter进行动画处理.\n小结 以上我们了解了动画的类型以及如何选择创建动画方式。通过下面的动画决策树，可以帮助你选择最适合你的动画方式:\n当然动画的难易程度已从隐式动画、显式动画、自定义绘制CustomPainter递增。 .\n",
    "ref": "/blog/flutter_animation_start/"
  },{
    "title": "关于我",
    "date": "",
    "description": "一个会点 Flutter 的 iOSer，目前正在努力脱贫中！",
    "body": " 余武超/男/1991 本科/东华理工大学/信息管理与信息系统 工作年限：6年 期望职位：iOS高级程序员 期望城市：上海 Github：https://github.com/yuwuchaio  联系方式  手机：17621373658 Email：656733936@qq.com  工作经历 上海狮搏实业投资有限公司 （2017年4月 ~ 至今 ） 88共享出行 88共享出行是一款为用户提供便捷、安全、实惠的“共享化”出行解决方案的App。平台目前有拼车、共享汽车、共享班车三个业务模块，相互支撑，满足工作通勤和休闲出行的需求。\n主要工作：\n 负责推动项目的组件化，采用 cocoapods 抽取基础组件（日志、分享、工具分类、本地存储等）及功能组件（支付、地图、定位），分离拼车、班车、租车等业务线。通过中间路由完成各模块间的调用。 在开发过程中定期对App的ipa包大小压缩（通过图片压缩、LinkMap 结合 Mach-O删除未使用的代码） 结合 WKWebView 和 前端约定，制定 App 和前端的交互方式替换原先传统拦截跳转方式。 搭建（Fastlane + pgyer）自动打包测试环境，提升测试效率。  上海逸尚信息咨询有限公司 （ 2015年10月 ~ 2017年4月 ） 优料宝 优料宝是一个面向设计师的O2O面料营销平台，主要是为面料商和设计师提供直接沟通的平台。\n主要工作：个人作为核心开发在项目中负责产品模块、会员模块、购物车模块、环信聊天模块及公用模块的开发维护。\n 在开发的过程中优化了公司代码的公共库类（减少公共库间的依赖，降低代码的耦合性。做到库之间尽量独立）。 与后台一起，独立完成环信聊天模块。 由于Apple审核时长的特殊性，主动调研使用JSpatch编写Hotfix脚本集成在项目中使用，补充了线上事故的补救能力（目前由于苹果审核规则现已经下线使用）。  国美在线电子商务有限公司（北京）（ 2014年7月 ~ 2015年8月 ） 国美 国美是国美电器唯一官方网上商城App，中国领先的专业家电网购平台。\n主要工作：个人在项目中负责会员中心模块。主要负责钱包、订单、优惠券、登录。\n 参与项目日常任务开发、维护及自测工作. 使用Analyze分析代码中潜在问题、使用Instrument检测内存泄漏、分析代码的执行时间等。 参与需求评审并开发、讨论API接口设计、交互改善。 参加Code Review，确保提交高质量的代码，完成开发任务。  技能清单  精通Objective-C语言，熟悉 Objective-C 的底层原理、内存管理。 熟悉runtime、runloop机制,了解 Swift。 熟悉常用存储技术：FMDB、NSUserDefaults。 熟悉 iOS 常用开发工具：Instrument、Charles 、Wireshark 熟悉协议相关：HTTP/HTTPS、TCP/IP。 熟练掌握SVN、Git、cocoapods及GitFlow开发流程 熟悉常用的三方库AFNetwork、SDWebImaage、YYModel、ASpect等。  ",
    "ref": "/about/"
  }]
